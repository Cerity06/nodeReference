---
title: 'MongoDB and Mongoose'
description: 'Back-end development with node JS and Express'
date: '13 mars 2022'
author: 'John Lawlet'
image: ''
---

# MONGOOSE

## GETTING STARTED

"npm install mongoose --save"

## SCHEMA

**Definition:** Schema maps to a MongoDB collection and defines the shape of the documents within that collection.

```ts
import mongoose from 'mongoose';
const { Schema } = mongoose;

const blogSchema = new Schema({
  title: String, // String is shorthand for {type: String}
  author: String,
  body: String,
  comments: [{ body: String, date: Date }],
  date: { type: Date, default: Date.now },
  hidden: Boolean,
  meta: {
    votes: Number,
    favs: Number,
  },
});
```

## CREATING A MODEL

To use our schema definition, we need to convert our blogSchema into a Model we can work with.

```ts
// mongoose.model(modelName, schema)
const Blog = mongoose.model('Blog', blogSchema);
```

**ids:** by default, Mongoose adds an "\_id" property to your schemas.
**instance methods:** instances of Models are documents. Documents have many of their own built-in instance methods.

```ts
// define a schema
const animalSchema = new Schema({ name: String, type: String });

// assign a customize function to the "methods" object of our animalSchema
animalSchema.methods.findSimilarTypes = function (cb) {
  return mongoose.model('Animal').find({ type: this.type }, cb);
};
```

**query helpers** functions which are like instance methods but for mongoose queries.

```ts
animalSchema.query.byName = function (name) {
  return this.where({ name: new RegExp(name, 'i') });
};

const Animal = mongoose.model('Animal', animalSchema);

Animal.find()
  .byName('fido')
  .exec((err, animals) => {
    console.log(animals);
  });

Animal.findOne()
  .byName('fido')
  .exec((err, animal) => {
    console.log(animal);
  });
```

**Virtuals**: document properties that you can get and set but that do not get persisted to MongoDB.

- Not stored: impossible to query with them!!

```ts
personSchema
  .virtual('fullName')
  .get(function () {
    return this.name.first + ' ' + this.name.last;
  })
  .set(function (v) {
    this.name.first = v.substr(0, v.indexOf(' '));
    this.name.last = v.substr(v.indexOf(' ') + 1);
  });

axl.fullName = 'William Rose'; // Now `axl.name.first` is "William"
```

## Options Schema

```ts
new Schema({..}, options);

// INDEX - builds can also create significant load on your production database.
const schema = new Schema({..}, { autoIndex: false });

// DISCRIMINATORYKEY - Mongoose adds a path to your schema that stores which discriminator a document is an instance of
// you can set discriminatorKey to overwrite default
const baseSchema = new Schema({}, { discriminatorKey: 'type' });
// Without `discriminatorKey`, Mongoose would store the discriminator
// key in `__t` instead of `type`
doc.type; // 'Person'

// ID - Mongoose assigns each of your schemas an id virtual getter by default which returns the document's _id
console.log(user.id) // id of user instance of User model

// STRICT - (enabled by default)
// values passed to our model constructor that were not specified in our schema do not get saved to the db.
const thingSchema = new Schema({..}, { strict: false });

// TIMESTAMPS - tells Mongoose to assign createdAt and updatedAt fields to your schema (Date)
const thingSchema = new Schema({..}, { timestamps: { createdAt: 'created_at' } });)
const Thing = mongoose.model('Thing', thingSchema);
const thing = new Thing();
await thing.save(); // `created_at` & `updatedAt` will be included

// With updates, Mongoose will add `updatedAt` to `$set`
await Thing.updateOne({}, { $set: { name: 'Test' } });

// If you set upsert: true, Mongoose will add `created_at` to `$setOnInsert` as well
await Thing.findOneAndUpdate({}, { $set: { name: 'Test2' } });
```

## SCHEMA TYPES

**Types:** String, Number, Date, Buffer, Boolean, Mixed, ObjectId, Array, Decimal128, Map.

- Mixed:
  - Can change the value to anything else, you can change the value to anything else you like.
  - But no auto detect and save those changes.
  - need to call "doc.markModified(path)".

```ts
person.anything = { x: [3, 4, { y: 'changed' }] };
person.markModified('anything');
person.save(); // Mongoose will save changes to `anything`.
```

**All Schema Types:**
**required:** boolean or function, if true adds a required validator for this property.
**default:** Any or function, sets a default value for the path. If the value is a function, the return value of the function is used as the default.
**select:** boolean, specifies default projections for queries.
**validate:** function, adds a validator function for this property.
**get:** function, defines a custom getter for this property using Object.defineProperty().
**set:** function, defines a custom setter for this property using Object.defineProperty().
**alias:** string, mongoose >= 4.10.0 only. Defines a virtual with the given name that gets/sets this path.
**immutable:** boolean, defines path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has isNew: true.
**transform:** function, Mongoose calls this function when you call Document#toJSON() function, including when you JSON.stringify() a document.

**Indexes**
**index:** boolean, whether to define an index on this property.
**unique:** boolean, whether to define a unique index on this property.
**sparse:** boolean, whether to define a sparse index on this property.

**String**
**lowercase:** boolean, whether to always call .toLowerCase() on the value.
**uppercase:** boolean, whether to always call .toUpperCase() on the value.
**trim:** boolean, whether to always call .trim() on the value.
**match:** RegExp, creates a validator that checks if the value matches the given regular expression.
**enum:** Array, creates a validator that checks if the value is in the given array.
**minLength:** Number, creates a validator that checks if the value length is not less than the given number.
**maxLength:** Number, creates a validator that checks if the value length is not greater than the given number.
**populate:** Object, sets default populate options.

**Number**
**min:** Number, creates a validator that checks if the value is greater than or equal to the given minimum.
**max:** Number, creates a validator that checks if the value is less than or equal to the given maximum.
**enum:** Array, creates a validator that checks if the value is strictly equal to one of the values in the given array.
**populate:** Object, sets default populate options.

**Date**
**min:** Date
**max:** Date

```ts
// markModified() link logic of type Date to its methods
const Assignment = mongoose.model('Assignment', { dueDate: Date });
Assignment.findOne(function (err, doc) {
  doc.dueDate.setMonth(3);
  doc.save(callback); // THIS DOES NOT SAVE YOUR CHANGE

  doc.markModified('dueDate');
  doc.save(callback); // works
});
```

**ObjectId**
**populate:** Object, sets default populate options

**Special Maps**

- A MongooseMap is a subclass of JavaScript's Map class => nested document with arbitrary keys.

```ts
const userSchema = new Schema({
  // `socialMediaHandles` is a map whose values are strings. A map's
  // keys are always strings. You specify the type of values using `of`.
  socialMediaHandles: {
    type: Map,
    of: String,
  },
});

const User = mongoose.model('User', userSchema);
// Map { 'github' => 'vkarpov15', 'twitter' => '@code_barbarian' }
console.log(
  new User({
    socialMediaHandles: {
      github: 'vkarpov15',
      twitter: '@code_barbarian',
    },
  }).socialMediaHandles
);

// Must use .get() to get the value of a key and .set() to set the value of a key.
user.socialMediaHandles.set('github', 'vkarpov15');
```

## CONNECTIONS

- Connect to MongoDB with the mongoose.connect() method.
- Default port: 27017 on localhost || 127.0.0.1

**ERROR HANDLING**

- **Error on initial connection:** it won't try to reconnect.
- **Error after initial connection:** it will emit an 'error' event.

```ts
try {
  await mongoose.connect('mongodb://localhost:27017/test');
} catch (error) {
  handleError(error);
}

mongoose.connection.on('error', (err) => {
  logError(err);
});

mongoose.connection.on('disconnected', (err) => {
  logError(err);
});
```

**OPTIONS**

- **user/pass:** The username and password for authentication.
- **authSource:** The DB to use when authenticating with user and pass. In MongoDB, users are scoped to a database.
- If you are getting an unexpected login failure, you may need to set this option.
  - Mongoose-specific, equivalent to MongoDB driver's auth.username and auth.password options.
- **autoIndex:** great for development.
  - Not ideal for large production deployments, because index builds can cause performance degradation.
- **Sockets**: maxPoolSize, minPoolSize, socketTimeoutMS,

```ts
const options = {
  autoIndex: false, // Don't build indexes
  maxPoolSize: 10, // Maintain up to 10 socket connections
  serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
  socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
  family: 4, // Use IPv4, skip trying IPv6
};
mongoose.connect(uri, options);
```

**CONNECTION EVENTS:**

events: connecting, connected, open, disconnecting, disconnected, close, reconnected, error (on connection), all...

- For long running applications: often prudent to enable keepAlive with a number of milliseconds

```ts
mongoose.connect(uri, { keepAlive: true, keepAliveInitialDelay: 300000 });
```

**MULTIPLE CONNECTIONS**

```ts
const conn = mongoose.createConnection(
  'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]',
  options
);

// complete example with several models to multiple connections
const mongoose = require('mongoose');

module.exports = function connectionFactory() {
  const conn = mongoose.createConnection(process.env.MONGODB_URI);

  conn.model('User', require('../schemas/user'));
  conn.model('PageView', require('../schemas/pageView'));

  return conn;
};
```

**SSL CONNECTIONS**

- By default: The SSL option defaults to FALSE with mongodb:// but TRUE with mongodb+srv://.
- srv connection string to connect to MongoDB Atlas => SSL is enabled by default.

```ts
mongoose.connect('mongodb://localhost:27017/test', { ssl: true });

// More about SSL: https://mongoosejs.com/docs/tutorials/ssl.html
```

## MODELS

- Models are fancy constructors compiled from Schema definitions. An instance of a model is called a document.
- Models are responsible for creating and reading documents from the underlying MongoDB database.

```ts
const schema = new mongoose.Schema({ name: 'string', size: 'string' });
const Tank = mongoose.model('Tank', schema);
```

## DOCUMENTS

- Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB.
- **Documents vs Models:** each document is an instance of its Model.
- The Model class is a subclass of the Document class.

**Updating using save()**

- The save() method returns a promise. If save() succeeds, the promise resolves to the document that was saved.

```ts
// generally the right way to update a document with Mongoose.
// With save(), you get full validation and middleware.
doc.save().then((savedDoc) => {
  savedDoc === doc; // true

  // OR instead of save() method - More flexible but more complex
  await MyModel.updateMany({}, { $set: { name: 'foo' } });
});
```

## Subdocuments

- Subdocuments are documents embedded in other documents.
- In Mongoose, this means you can nest schemas in other schemas.
- The major difference: they are not saved individually but whenever their top-level parent document is saved.

```ts
const Parent = mongoose.model('Parent', parentSchema);
const parent = new Parent({ children: [{ name: 'Matt' }, { name: 'Sarah' }] });
parent.children[0].name = 'Matthew';

// `parent.children[0].save()` is a no-op, it triggers middleware but
// does **not** actually save the subdocument. You need to save the parent
// doc.
parent.save(callback);
```

## QUERIES

- **DELETE:** deleteMany() - deleteOne() - findByIdAndRemove() - findOneAndRemove() - findByIdAndDelete() - findOneAndDelete()
- **GET:** find() - findOne() - findById() - findByIdAndUpdate()
- **UPDATE:** findOneAndUpdate() - updateOne() - updateMany()
- **REPLACE:** replaceOne() - findOneAndReplace()

## LEAN

- The lean option tells Mongoose to skip hydrating the result documents => faster and less memory intensive.
- plain old JavaScript objects (POJOs) instead of Mongoose documents.

**Usage:** if you do not modify the query results and do not use custom getters.

```ts
// As long as you don't need any of the Person model's virtuals or getters,
// you can use `lean()`.
app.get('/person/:id', function (req, res) {
  Person.findOne({ _id: req.params.id })
    .lean()
    .then((person) => res.json({ person }))
    .catch((error) => res.json({ error: error.message }));
});
// lean means no `save()`
// Possible to use plugins (virtuals, getters, default but in POJO)
```

**!! GET routes are good candidates for lean() !!**

## VALIDATION

- Validation is middleware. Mongoose registers validation as a pre('save') hook on every schema by default.

```ts
// Validation is customizable
const userSchema = new Schema({
  phone: {
    type: String,
    validate: {
      validator: function (v) {
        return /\d{3}-\d{3}-\d{4}/.test(v);
      },
      message: (props) => `${props.value} is not a valid phone number!`,
    },
    required: [true, 'User phone number required'],
  },
});
```

### VALIDATION ERROR

- Errors returned after failed validation contain an errors object whose values are ValidatorError objects.
- Each ValidatorError has kind, path, value, and message properties. May have a reason property.

## MIDDLEWARE

- Middleware are functions which are passed control during execution of asynchronous functions.
- 4 types: document middleware, model middleware, aggregate middleware, and query middleware.
- Parameters: validate, save, remove, updateOne, deleteOne, init (note: init hooks are synchronous).
- IMPORTANT: Define Middleware Before Compiling Models, otherwise it won't fire.

**Mongoose 5:** instead of calling next() manually => use a function that returns a promise (async/await).

```ts
// PRE MIDDLEWARE
schema.pre('save', async function () {
  await doStuff();
  await doMoreStuff();
});

// RETURN
const schema = new Schema(..);
schema.pre('save', function(next) {
  if (foo()) {
    console.log('calling next!');
    // `return next();` will make sure the rest of this function doesn't run
    /*return*/ next();
  }
  // Unless you comment out the `return` above, 'after next' will print
  console.log('after next');
});

// POST MIDDLEWARE
schema.post('validate', function(doc) {
  console.log('%s has been validated (but not saved yet)', doc._id);
});
schema.post('save', function(doc) {
  console.log('%s has been saved', doc._id);
});

// NEXT WITH ERROR
schema.pre('save', function(next) {
  const err = new Error('something went wrong');
  // If you call `next()` with an argument, that argument is assumed to be
  // an error.
  next(err);
});

// NEW WAY OF HANDLING ERRORS => Error Handling Middleware

// Handler **must** take 3 params: the error that occurred, the document
// in question, and the `next()` function
schema.post('save', function(error, doc, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    next(new Error('There was a duplicate key error'));
  } else {
    next();
  }
});

// WITH QUERIES
schema.post('update', function(error, res, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    next(new Error('There was a duplicate key error'));
  } else {
    next(); // The `update()` call will still error out.
  }
});

```

## POPULATE

- Process of automatically replacing the specified paths in the document with document(s) from other collection(s).

```ts
// populate instance Story with author instance of Person
Story.findOne({ title: 'Casino Royale' })
  .populate('author')
  .exec(function (err, story) {
    if (err) return handleError(err);
    console.log('The author is %s', story.author.name);
    // prints "The author is Ian Fleming"
  });
```
