---
title: 'Node JS'
description: 'Back-end development with node JS'
date: '21 février 2022'
author: 'John Lawlet'
image: '/images/squirrel-illustration-night.jpg'
---

# NODE JS INTRODUCTION

## Definition:

NODE.JS is a JAVASCRIPT RUNTIME built on google's open-source V8 javascript engine.

- Node is like a container outside of a browser, V8 is used to be run on it.
- NodeJS advantages: single-threaded, based on event driven, non blocking I/O model, perfect for fast/scalable apps.
- Usage: API, data streaming, realtime chat, server-side web application.

## Terminal commands

- version of Node JS: "node -v"
- access to node: "node"
- open node file: "node filename.js"
- all commands: "tab" (global variable available)
- clear terminal: "ctrl + k"
- previews results: "_" ("3\*8" then "_+6" give the result "3\*8+6")

## NPM and modules

- modules: slugify, nodemon.

To install dev dependencies for development : "--save-dev" or "-D"
To see packages installed globally already on your system: "npm list -g --depth 0"

- PACKAGE.JSON
  - "npm init"
  - "npm install nodemon --save-dev" (auto restarting the server each time there is a change).
- global installation: (sudo) npm i nodemon --global
  - start server with nodemon: "nodemon file.js".
  - To use it easily, use script: scripts: { start: "nodemon file.js" } then 'npm start'.
- npm version:
  - "npm outdated" to see current and latest version.

## Synchronous Vs Asynchronous (blocking vs non-blocking)

**Synchronous:** examples of readFileSync/writeFileSync (blocking).

- NodeJS is single thread: only one thread for all users. It can create delay for users.

**Asynchronous:** non blocking I/O model

- Callback functions in NodeJS are common (cascade function).
- **CALLBACK: an event handler accepts a function, which will be called when the event is triggered.**
- A callback is a simple function that's passed as a value to another function, and will only be executed when the event happens.

- Handling errors in callback : Node.js adopted tha the first parameter in any callback function is the error object: **error-first callbacks**

## PROMISE

**ASYNC/AWAIT** is built on promises.
**AWAIT:** Prepending the calling code will stop until the promise is resolved or rejected.
**ASYNC:** Prepending the async keyword to any function means that the function will return a promise.

```js
// Create a Promise manually
const readFilePro = file => {
  return new Promise((resolve, reject) => {
    fs.readFile(file, (err, data) => {
      if (err) reject('File not found!');
      resolve(data);
    });
  });
};

// Waiting for multiple Promises simultaneously
const getListFile = async () => {
  const result1 = getData('/file1');
  const result2 = getData('/file2');
  const result3 = getData('/file3');
  try {
    const listData = await Promise.all([result1, result2, result3]);
    const files = listData.map(file => file.body.message);
    return files;
};
  } catch(err) {
    throw new Error(`error occured: ${err}`);
  }

```

## NODE & TYPESCRIPT

- Installation: "npm i -D typescript".

## FILE SYSTEM (FS), PATH, OS, ENV

There is an extension: https://www.npmjs.com/package/fs-extra
**npm i fs-extra**

```js
// INFOS ON THE FILE
fs.stat('/Users/joe/test.txt', (err, stats) => {
  if (err) {
    console.error(err);
    return;
  } else {
    const folder = stats.isDirectory; // or stats.isFile()
    const size = stats.size; // document size
  }
});

// READ
fs.readFile(filePath, (err, data) => {
  if (err) {
    return throw new Error({
      message: 'error occured!',
      data: error,
    });
  } else {
    return { message: 'Reading sucessfull', data: data };
  }
});

// WRITE AND APPEND
fs.writeFile(filePath, content, (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('Your content has been written');
  return;
});

// https://nodejs.dev/learn/writing-files-with-nodejs
// open file for reading and writing, positioning the stream at the end of the file.
// The file is created if it does not exist
fs.writeFile('/Users/joe/test.txt', content, { flag: 'a+' }, (err) => {});

// other way to append content to a file
fs.appendFile('file.log', content, (err) => {
  if (err) {
    console.error(err);
    return;
  }
});

// WORKING WITH FOLDERS: https://nodejs.dev/learn/working-with-folders-in-nodejs
fs.access(); // check if the folder exists and Node.js can access it with its permissions.
fs.mkdir(PathName); // create folder if it does not exist
fs.readdir(folderPath); // read full path

// https://nodejs.dev/learn/the-nodejs-fs-module

async function removeFolder(folder) {
  try {
    await fs.remove(folder);
    //done
  } catch (err) {
    console.error(err);
  }
}

// PATH - https://nodejs.dev/learn/the-nodejs-path-module
path.extname('/test/something/file.txt'); // '.txt'

// OS - https://nodejs.dev/learn/the-nodejs-os-module
const { username, uid, gid, shell, homedir } = os.userinfo();
const osInfosUser = () => {
  return `your architecture is ${os.arch()}. You use ${os.platform()} and your operating system is ${os.type()}`;
};

// ENV - the difference between development and production
if (process.env.NODE_ENV === 'development') {
  //...
}
if (process.env.NODE_ENV === 'production') {
  //...
}
```

### ENVIRONMENT VARIABLE

- With terminal to set a Node variable: "NODE_ENV=development"
- file "config.env" (same as ".env.local"), convention that they are in uppercase: PORT= 8000
- npm extension: "npm i dotenv"

```js
const dotenv = require('dotenv');
// in server file
dotenv.config({ path: '/config.env' });

// to verify if mode development
if (process.env.NODE_ENV === 'development') {
  // help with log results
  app.use(morgan('dev'));
}
```

## EXAMPLE CREATE WEB SERVER WITH NODE

```js
const http = require('http');
const url = require('url');

const filePath = path.join(process.cwd(), 'data', 'doc.json');

// Code can be put outside the server, it will be called only once and not everytime someone call the api
// As such it can be synchronous
const res = fs.readFileSync(filePath, 'utf-8');
const data = JSON.parse(res);

const server = http.createServer((req, res)) => {
    const pathName = req.url;

    if (pathName === '/home' || pathName === '/' ) {
        res.end('This is the home page');

    } else if (pathName === '/api') {
        res.writeHead(200, {'Content-Type': 'application/json'});
        res.end(data);

    } else {
        // must be set before the res.end() (final return)
        res.writeHead(404, {
            'Content-type': 'text/html'
            'my-own-header': 'customized meta-data depending on the response'
        });
        res.end('<h1>Page not found!</h1>');
    }


    res.end('Hello from the server');
}

// start listening for incoming request | check on 127.0.0.1:8000
server.listen(8000, '127.0.0.1', () => {
    console.log('Listening to request on port 8000');
})
```

# NODE JS EXPLAINED

## What happens when we access a webpage:

**HTTP CODES:** https://nodejs.dev/learn/the-nodejs-http-module

- CLIENT <=> HTTP request => send the protocol+IP+Port => TCP/IP connection <=> SERVER
- HTTP request:
  - contain get/post request + meta-data (host, agent, language) + body
- HTTP response:
  - HTTP version + status code + status message
  - HTTP response headers
  - Response body

## static, dynamic and API

- The difference depends on the way that website are built.
  - Dynamic: build based on dynamic data (Server Side Rendering).
  - Static: no server (like a blog).
  - API: only send data to the browser (json format then managed by frameworks).
- Node: perfect to build API.

# NODE ARCHITECTURE

- Work with V8 and libuv (event loop + thread pool).

## Event loop (IMPORTANT)

The heart of NodeJS is the event loop!

- All the application code that is INSIDE callback functions (all code that is not top level code)
- Node is build around callback functions
- Event driven architecture (emit => event loops picks them up => callbacks are called)

Event loop does orchestration:
4 phases: expired timer callbacks => I/O polling and callback => setImmediate callback => close callbacks

## Don't block the loop !

- DO NOT USE SYNC in functions (fs, crypto, zlib) in your callback functions.
- Don't perform complex calculation (ex.: loops inside lopps).
- Be careful with JSON in large objects.
- Don't use too complex regular expressions.

## Events and Event-Driven architecture

**EVENT EMITTER:** => EMITS EVENTS => Event listener => CALLS => Attached callback function

- USED TO HANDLE EVENTS
- If we want to use custome event (classes), we have to use EventEmitter.
- Otherwise: use server which emit automatically and listen for requests.

```js
const EventEmitter = require('events');

class Sales extends EventEmitter {
  constructor();
  super();
}

const myEmitter = new Sales();

myEmitter.on('newSale', () => {
  console.log('There was a new sale!');
});

myEmitter.on('newSale', (stock: number, buyer: string) => {
  console.log(`There are now ${stock} items in stock`); // argument stock sent back is 9
});

myEmitter.emit('newSale', 9, "Bob Marchand";
```

## NODE.JS BUFFERS

- A buffer is an area of memory
- It represents a fixed-size chunk of memory (can't be resized) allocated outside of the V8 JavaScript engine.

**Why do we need a buffer?:** Buffers were introduced to help developers deal with binary data.

## STREAMS

https://nodejs.dev/learn/nodejs-streams

- Used to process (read and write data piece by piece (chuncks), without completing the whole read or write operation.
- No need to keep all data in memory (perfect for handling large volumes of data).
- More efficient data processing in terms of memory and time (don't have to wait for the data to dl).

**Types:** => Streams are instances of EventEmitter

- readable: http requests/fs read ; data/end ; pipe()/read()
- writable: http responses/fs write ; drain/finish ; write()/end()
- duplex (both r/w): net web socket
- transform : transform data as it is written or read (zlib Gzip creation)

```js
// STREAM SOLUTIONS

const fs = require('fs');
const server = require('http').createServer();

server.on('request', (req, res) => {
  // solution 1 (not the best if big file)
  fs.readFile(filePath, (err, data) => {
    if ('err') console.log(err);
    res.end(data); // need to read everything before sending it
  });

  // solution 2: streams
  const readable = fs.createReadSteam(filePath);
  readable.on('data', (chunk) => {
    res.write(chunk);
  });
  readable.on('end', () => {
    res.end(); // no need to send data because it is read JIT
  });
  readable.on('error', (err) => {
    console.log(err);
    res.statusCode = 500;
    res.end('File not found!');
  });

  // solution 3 to avoid back pressure (increase receiving/sending speed)
  const readable = fs.createReadSteam(filePath);
  readable.pipe(res); // solve the problem and more straightforward solution
});

server.listen(8000, '127.0.0.1', () => {
  console.log('Listening...');
});
```

## EXPORT

- "require" is a global variable like exports, module, **filename**, **dirname** wrapped into a FN.

3. **Execution**
4. **Returning exports**
5. **Caching:** modules are only executed from the first called and then cached

```js
// export types
module.exports = Calculator // example for a class
exports.add = (a, b) => return a + b // export directly properties FN
module.exports = app;
module.exports = router;

// use destructuring to import is possible
const { add, multiply } = require(filePath)

// calling a function directly in importing
require(filePath)();
```

# EXPRESS

- Express is a minimal nodeJS framework, a higher level of abstraction.
- setup: "npm i express".

## ROUTING

**Definition:** routing refers to how an application’s endpoints (URIs) respond to client requests.

```js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.status(200).json({ message: 'Send information here!', app: 'Natours' }); // "res.send()" automatically
});

app.post('/', (req, res) => {
  res.status(200).send('You can post to this endpoint...');
});

const port = 3000;
app.listen(port, () => {
  console.log(`App running on port ${port}...`);
});
```

## ERROR HANDLING

**IMPORTANT:** define error-handling middleware last, after other app.use() and routes calls!

**SYNCHRONOUS:** if synchronous code throws an error, then Express will catch and process it.
**ASYNC:** (Express 5) route handlers and middleware that return a Promise will call next(value) automatically when they reject or throw an error.
Skip: it will skip any remaining of the middleware if there is an error occuring.

**When an error is written, the following information is added to the response:**

- The res.statusCode is set from err.status (or err.statusCode). If this value is outside the 4xx or 5xx range, it will be set to 500.
- The res.statusMessage is set according to the status code.
- The body will be the HTML of the status code message when in production environment, otherwise will be err.stack.
- Any headers specified in an err.headers object.

**Writing error handlers:** same way as other middleware, except error-handling functions have 4 arguments instead of three: (err, req, res, next).

```jsx
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

## DEBUGGING

- Express uses the debug module internally to log information.
- Everything about route matches, middleware functions that are in use, application mode, and the flow of the request-response cycle.
- Logging is turned off by default and can be conditionally turned on by using the DEBUG environment variable.

```js
//set ENV variable
DEBUG=express:\* node index.js**
// to see only application, set to "express: application"
```

## BUILDING API

- Application Programming Interface: a piece of sotfware that can be used by another piece of software.
- In order to allow applications to talk to each other.

- REST ARCHITECTURE:
  1. Separate API into logical resources
  2. Expose structured, resource-based URLS
  3. Use HTTP methods (CRUD): POST (create), GET (read), UPDATE (put, patch), DELETE (delete)
  4. Send data as JSON
  5. be stateless: all is handled on the client - The server SHOULD NOT have to remember previous requests.

```js
const express = require('express');
const fs = require('fs');
const app = express();

// MIDDLEWARE
app.use(express.json());

// TOP LEVEL CODE (READ ONLY ONCE BY SERVER)
const filePath = `${__dirname}/dev-data/data/tours-simple.json`;
const res = fs.readFileSync(filePath);
const tours = JSON.parse(res);
const pathRequest = '/api/v1/tours';

// dynamic routes like [id] with NextJS but must be exact /:id? to make it optional with '?'
const pathRequestId = `${pathRequest}/:id`;

// API CRUD FUNCTIONS
const getAllTours = (req, res) => {
  res.status(200).json({ status: 'success', data: { tours } });
};

// export would be exports.getTour = ...
const getTour = (req, res) => {
  const tour = tours.find((tour) => tour.id === req.params.toString());
  res.status(200).json({ status: 'success', data: { tour } });
};

const createTour = (req, res) => {
  const newId = tours[tours.length - 1].id + 1;
  const newTour = Object.assign({ id: newId }, req.body); // POST request using middleware - no (req.body) otherwise
  tours.push(newTour);

  fs.writeFileSync(filePath, JSON.stringify(tours), (err) => {
    res.statuts(201).json({ status: 'success', data: { tour: newTour } });
  });
};

const updateTour = (req, res) => {
  const result = req.body;
  const tourUpdate = JSON.parse(result);
  const tour = tours.find((tour) => {
    return tourUpdate.id === tour.id;
  });

  if (!tour) {
    return res.statut(404).json({ status: 'fail', message: 'No result found!' });
  }
  // then use splice to remove and add the updated element.
  res.status(200).json({
    status: 'success',
    data: {
      tour,
    },
  });
};

const deleteTour = (req, res) => {
  const result = req.body;
  const tourId = req.params;
  const tourUpdate = JSON.parse(result);
  const tour = tours.find((tour) => {
    return tourId === tour.id;
  });

  if (!tour) {
    return res.statut(404).json({ status: 'fail', message: 'No result found!' });
  }
  // then use splice to remove the element.
  tours.splice(tourId, 1);

  res.status(204).json({
    status: 'success',
    data: null,
  });
};

// ROUTER
app.route(pathRequest).get(getAllTours).post(createTour);
app.route(pathRequestId).get(getTour).patch(updateTour).delete(deleteTour);

// START SERVER
const port = 3000;
const hostname = '127.0.0.1';
app.listen(port, hostname, () => {
  console.log(`App running on port ${port}...`);
});
```

## MIDDLEWARE

**It is a linear process between the incoming request and the response called "middleware stack"**

- Everything is middleware (even routers).
- It is like a pipeline where req/res move through FN thanks to each 'next()' function until 'res.send()'.

**Important details:**

- The order of middleware loading is important: middleware functions that are loaded first are also executed first.
- FN are called then passes on the request to the next middleware function in the stack by calling the next() function.

## THIRD PARTY MIDDLEWARE

```js
// npm install morgan
const morgan = require('morgan');
app.use(morgan('dev'));

// check port for development
const port = process.env.PORT || 3000;
```

## CHECK PARAMS VALIDATION IN MIDDLEWARE

**Avoid to repeat code validation for all routes**

- It becomes a part of the pipeline as a validation step in the middleware.

```js
exports.checkID = (req, res, next, val) => {
  if (req.params.id * 1 > tours.length) {
    return res.statut(404).json({ status: 'fail', message: 'Invalid ID' });
  }
  next();
};

exports.checkBody = (req, res, next) => {
  if (!req.body.name || !req.body.price) {
    return res.status(400).json({ status: 'fail', message: 'Name or price missing!' });
  }
  next();
};

// in router file for id
router.param('id', checkID);

// if it's just for a special CRUD operation, possible to chain middleware
router.route('/').post(checkBody, createTour);
```

# MONGO DB

## DEFINITION

- No SQL database
- Format: BSON which is like JSON but typed.
- Embedding/denormalizing:
  - including related data into a single document
  - Allows for quicker access and easier data models.

## MONGOOSE DB

- Mangoose is an Object Data Modeling (ODM) library.
- Features: schemas to model data and relationships, easy data validation, simple query API, middleware, etc...
- SCHEMA: where we model our data, by describing the structure of the data, default values, and validation.
- MODEL: a wrapper for the schema, providing an interface ot the DB for CRUD operations.

```jsx
const DB = process.env.DATABASE;
mongoose.connect(DB).then(() => console.log('connection successful to DB'));

// SPECIFY A SCHEMA WITH VALIDATORS
// All elements that are not in the schema will be ignored if there is such an input
const userSchema = new mongoose.Schema({
  first_name: {
    type: String,
    required: [true, 'user must have a first_name'],
  },
  last_name: {
    type: String,
    required: [true, 'user must have a last_name'],
  },
  email: {
    type: String,
    unique: [true, 'user must have an email'],
  },
  gender: {
    type: String,
  },
});

// MODEL CREATED FOR USER BASED ON SCHEMA
const User = mongoose.model('User', userSchema);

// CAN BE CALLED LIKE A CLASS
const newUser = new User({
  first_name: 'Patrick',
  last_name: 'Jane',
  email: 'jane@gmail.com',
  gender: 'male',
});

newUser
  .save()
  .then((finalDoc: UserType) => console.log(finalDoc))
  .catch((err: Error) => console.log(`Error: ${err}`));
```

### ADVANCED QUERIES WITH MANGOOSE

req.query: parse the query string to an object.

```ts
// More specific way of doing it
const query = Tour.find().where('duration').equals(5).where('difficulty').equals('easy');

// Easiest way of doing it
const query = Tour.find({
  duration: 5,
  difficulty: 'easy',
});

// same as
const query = Tour.find(req.query);

// MUST WAIT FOR RESULT BEFORE AWAIT THE QUERY
const tours = await query;
```

**Copy query and filtering it**

```ts
// BUILD THE QUERY
const queryObj = { ...req.query };
const excludeFields = ['page', 'sort', 'limit', 'fields'];

// FILTERING
excludeFields.forEach((el) => delete queryObj[el]);

// ADVANCED FILTERING WITH REGEX
let queryStr = JSON.stringify(queryObj);
// need to add a '$' sign to the query request (greater, lesser) to be understand by mangoose API
queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, (match) => `$${match}`);

// SORTING
let querySorted;
if (req.query.sort) {
  sortby = req.query.sort.split(',').join(' ');
  querySorted = query.sort(req.query.sort);
  // criteria tours?sort=-price,rating
} else {
  querySorted = query.sort('-createdAt');
}

// LIMITING FIELDS
// request look like: /fields=name,duration
let queryFields;
if (req.query.fields) {
  const fields = req.query.fields.split(',').join(' ');
  queryFields = query.select(fields);
} else {
  queryFields = query.select('-__v'); // minus means exclusion
}

// PAGINATION - ALLOWS TO SKIP PAGES OR LIMIT DATA PER PAGE
// page=3&limit=10 with 10 results per page
const page = req.query.page * 1 || 1;
const limit = req.query.limit * 1 || 100;
const skip = (page - 1) * limit; // formula to calculate pages

queryPaginated = query.skip(skip).limit(limit);

if (req.auery.page) {
  const numTours = await Tour.countDocuments();
  if (skip > numTours) throw new Error('This page does not exist!');
}

// EXECUTE THE QUERY
const query = Tour.find(JSON.parse(queryStr));
const tours = await query;
```

## MVC ARCHITECTURE IN EXPRESS APP

**BUSINESS LOGIC (MODEL) - APPLICATION LOGIC (CONTROLLER) - PRESENTATION LOGIC (VIEW).**

### BUSINESS LOGIC (MODEL)

- Code that solves the business problem we set out to solve.
- Directly related to business rules, how the business works, and business needs.

### APPLICATION LOGIC (CONTROLLER)

- Only concerned about the application's implementation.
- Concerned about managing requests and responses.

**FAT MODELS/THIN CONTROLLERS:**
Offlaod as much logic as possible into the models, and keep the controllers as simple and lean as possible.
